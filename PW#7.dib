#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №7.Реализация потока обработки команад.

**Цель:** Реализовать основу для многопоточного сервера приложений.

**Результаты:** После выполнения работы Вы сможете:
1. Обрабатывать множество операций в несколько потоков.
2. Останавливать потоки по запросу извне.

## Задание.
Пусть операция задана интерфейсом

#!csharp

public interface ICommand
{
    void Execute();
}

#!markdown

Классы, наследующие интерйес ICommand будем называть **Командами.**

Реализовать класс ServerThread и команды по hard и soft завершению потока. 

ServerThread может менять свое поведение для обработки следующей Команды.
Исключение, выброшенное из Команды, перехватывается и передается вместе с самой Командой в ExceptionHandler (см. ЛР №5) Примечание. Наличие реализованного обработчика исключений не обязательно для выполнения данной задачи. 

Команда HardStop приводит к немедленной остановке потока, несмотря на, что в очереди потока есть еще Команды.
Команда  SoftStop останавливает поток, когда в очереди потока закончатся все Команды.

Команды HardStop и SoftStop успешно выполняются только в потоке, который они должны остановить, в противном случае выбрасывают исключение.
Отсутствие Команд в очереди потока не должно требовать значительных затрат процессорного времени. Значительными считаются затраты, которые зависят от времени простоя потока.

Написать проверку, которая гарантирует правильное выполнение команд HardStop и SoftStop.

#!csharp

using System;
using System.Collections.Concurrent;
using System.Threading;

#!csharp

public class ServerThread {

    private ConcurrentQueue<ICommand> commands = new ConcurrentQueue<ICommand>();
    private bool hardStop = false;
    private bool softStop = false;
    public bool isRunning = true;

    public int id { get; set; }

    public void Start() {
        Thread thread = new Thread(Run);
        thread.Start();
        id = thread.ManagedThreadId;
    }

    public void AddToQueue(ICommand command) {    
        if (command is HardStopCommand) {
            Console.WriteLine($"Queue coinains {commands.Count()} commands");
            commands.Clear();
            Console.WriteLine("HardStop");
            commands.Enqueue(command);
        }        
        else {
            commands.Enqueue(command);
        }
    }

    public void HardStop() {
        hardStop = true;
    }

    public void SoftStop() {
        softStop = true;
    }

    private void Run()
    {
        while(!hardStop)
        {
            if(commands.TryDequeue(out ICommand command)) {
                command.Execute();                
            }
            else {
                if(softStop) {
                    Console.WriteLine($"Queue contains {commands.Count()} elements");
                    Console.WriteLine("SoftStop");
                    isRunning = false;
                    break;
                }
                else {
                    Thread.Sleep(100);
                    continue;
                }
            }
        }
        isRunning = false;
    }
    
}


public class HardStopCommand : ICommand {

    private ServerThread thread;

    public HardStopCommand(ServerThread thread) {
        this.thread = thread;
    }

    public void Execute() {
        if(Thread.CurrentThread.ManagedThreadId == thread.id) {
            thread.HardStop();
        }
        else {
            throw new ("HardStop can only be executed in the thread it is stopping");
        }
    }
}

public class SoftStopCommand : ICommand {
    
    private ServerThread thread;

    public SoftStopCommand(ServerThread thread) {
        this.thread = thread;
    }

    public void Execute() {
        if(Thread.CurrentThread.ManagedThreadId == thread.id) {
            thread.SoftStop();
        }
        else {
            throw new ("SoftStop can only be executed in the thread it is stopping");
        }
    }
}

public class BasicCommand : ICommand {

    public void Execute() {
        int result = 0;
        for(int i = 0; i < 100000; i ++) {
            result += i;
        }
        Console.WriteLine($"Basic result {result}");

    }
}

#!csharp

ServerThread thread = new ServerThread();
thread.Start();
for(int i = 0; i < 10; i ++) {
    thread.AddToQueue(new BasicCommand());
}
thread.AddToQueue(new SoftStopCommand(thread));
while(thread.isRunning) {
    Thread.Sleep(100);
}
Console.WriteLine("All threads finished work");

#!csharp

ServerThread thread = new ServerThread();
thread.Start();
for(int i = 0; i < 10; i ++) {
    thread.AddToQueue(new BasicCommand());
}
thread.AddToQueue(new HardStopCommand(thread));
while(thread.isRunning) {
    Thread.Sleep(100);
}
Console.WriteLine("All threads finished work");
